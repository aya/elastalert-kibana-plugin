'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _path = require('path');

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _file_system = require('./file_system');

var _file_system2 = _interopRequireDefault(_file_system);

var _config = require('src/common/config');

var _config2 = _interopRequireDefault(_config);

var _logger = require('src/common/logger');

var _logger2 = _interopRequireDefault(_logger);

var _rule_request_errors = require('src/common/errors/rule_request_errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var logger = new _logger2.default('RulesController');

var RulesController = function () {
  function RulesController() {
    _classCallCheck(this, RulesController);

    this._fileSystemController = new _file_system2.default();
    this.rulesFolder = this._getRulesFolder();
  }

  _createClass(RulesController, [{
    key: 'getRules',
    value: function getRules(path) {
      var self = this;
      var fullPath = (0, _path.join)(self.rulesFolder, path);
      return new Promise(function (resolve, reject) {
        self._fileSystemController.readDirectory(fullPath).then(function (directoryIndex) {

          directoryIndex.rules = directoryIndex.files.filter(function (fileName) {
            return (0, _path.extname)(fileName).toLowerCase() === '.yaml';
          }).map(function (fileName) {
            return fileName.slice(0, -5);
          });

          delete directoryIndex.files;
          resolve(directoryIndex);
        }).catch(function (error) {

          // Check if the requested folder is the rules root folder
          if ((0, _path.normalize)(self.rulesFolder) === fullPath) {

            // Try to create the root folder
            (0, _mkdirp2.default)(fullPath, function (error) {
              if (error) {
                reject(new _rule_request_errors.RulesRootFolderNotCreatableError());
                logger.warn('The rules root folder (' + fullPath + ') couldn\'t be found nor could it be created by the file system.');
              } else {
                resolve([]);
              }
            });
          } else {
            logger.warn('The requested folder (' + fullPath + ') couldn\'t be found / read by the server. Error:', error);
            reject(new _rule_request_errors.RulesFolderNotFoundError(path));
          }
        });
      });
    }
  }, {
    key: 'rule',
    value: function rule(id) {
      var self = this;
      return new Promise(function (resolve, reject) {
        self._findRule(id).then(function (access) {
          resolve({
            get: function get() {
              if (access.read) {
                return self._getRule(id);
              }
              return self._getErrorPromise(new _rule_request_errors.RuleNotReadableError(id));
            },
            edit: function edit(body) {
              if (access.write) {
                return self._editRule(id, body);
              }
              return self._getErrorPromise(new _rule_request_errors.RuleNotWritableError(id));
            },
            delete: function _delete() {
              return self._deleteRule(id);
            }
          });
        }).catch(function () {
          reject(new _rule_request_errors.RuleNotFoundError(id));
        });
      });
    }
  }, {
    key: 'createRule',
    value: function createRule(id, content) {
      return this._editRule(id, content);
    }
  }, {
    key: '_findRule',
    value: function _findRule(id) {
      var fileName = id + '.yaml';
      var self = this;
      return new Promise(function (resolve, reject) {
        self._fileSystemController.fileExists((0, _path.join)(self.rulesFolder, fileName)).then(function (exists) {
          if (!exists) {
            reject();
          } else {
            //TODO: Get real permissions
            //resolve(permissions);
            resolve({
              read: true,
              write: true
            });
          }
        }).catch(function (error) {
          reject(error);
        });
      });
    }
  }, {
    key: '_getRule',
    value: function _getRule(id) {
      var path = (0, _path.join)(this.rulesFolder, id + '.yaml');
      return this._fileSystemController.readFile(path);
    }
  }, {
    key: '_editRule',
    value: function _editRule(id, body) {
      var path = (0, _path.join)(this.rulesFolder, id + '.yaml');
      return this._fileSystemController.writeFile(path, body);
    }
  }, {
    key: '_deleteRule',
    value: function _deleteRule(id) {
      var path = (0, _path.join)(this.rulesFolder, id + '.yaml');
      return this._fileSystemController.deleteFile(path);
    }
  }, {
    key: '_getErrorPromise',
    value: function _getErrorPromise(error) {
      return new Promise(function (resolve, reject) {
        reject(error);
      });
    }
  }, {
    key: '_getRulesFolder',
    value: function _getRulesFolder() {
      var ruleFolderSettings = _config2.default.get('rulesPath');

      if (ruleFolderSettings.relative) {
        return (0, _path.join)(_config2.default.get('elastalertPath'), ruleFolderSettings.path);
      } else {
        return ruleFolderSettings.path;
      }
    }
  }]);

  return RulesController;
}();

exports.default = RulesController;