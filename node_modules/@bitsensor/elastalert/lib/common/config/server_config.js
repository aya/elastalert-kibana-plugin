'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _joi = require('joi');

var _joi2 = _interopRequireDefault(_joi);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _schema = require('./schema');

var _schema2 = _interopRequireDefault(_schema);

var _objectResolvePath = require('object-resolve-path');

var _objectResolvePath2 = _interopRequireDefault(_objectResolvePath);

var _logger = require('../logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Config file relative from project root
var configFile = 'config/config.json';
var devConfigFile = 'config/config.dev.json';

var configPath = _path2.default.join(process.cwd(), configFile);
var devConfigPath = _path2.default.join(process.cwd(), devConfigFile);
var logger = new _logger2.default('Config');

var ServerConfig = function () {
  function ServerConfig() {
    _classCallCheck(this, ServerConfig);

    // ready() callbacks
    this._waitList = [];

    // Actual config
    this._jsonConfig = null;
  }

  /**
   * Get a value from the config.
   *
   * @param {String} key The key to load the value from.
   * @returns {*}
   */


  _createClass(ServerConfig, [{
    key: 'get',
    value: function get(key) {
      return (0, _objectResolvePath2.default)(this._jsonConfig, key);
    }

    /**
     * Register a callback to call when the config is ready loading.
     *
     * @param {Function} callback The callback to register.
     */

  }, {
    key: 'ready',
    value: function ready(callback) {
      this._waitList.push(callback);
    }

    /**
     * Loads the config by reading the config file or falling back to defaults.
     *
     * @returns {Promise} Returns a promise which resolves when everything is done (as a promise would).
     */

  }, {
    key: 'load',
    value: function load() {

      //TODO: Watch config file for changes and reload
      var self = this;
      return new Promise(function (resolve) {
        self._getConfig().then(function (config) {
          self._validate(config);
          resolve();
        });
      }).then(function () {
        self._waitList.forEach(function (callback) {
          callback();
        });
      });
    }
  }, {
    key: '_getConfig',
    value: function _getConfig() {
      var self = this;

      return new Promise(function (resolve) {
        self._fileExists(devConfigPath).then(function (devConfigFound) {

          // If a dev config was found read it, otherwise check for normal config
          if (devConfigFound) {
            self._readFile(devConfigPath).then(function (config) {
              resolve(config);
            }).catch(function () {
              resolve({});
            });
          } else {
            logger.info('Proceeding to look for normal config file.');
            self._fileExists(configPath).then(function (configFound) {
              if (configFound) {
                self._readFile(configPath).then(function (config) {
                  resolve(config);
                }).catch(function () {
                  resolve({});
                });
              } else {
                logger.info('Using default config.');
                // If no config was found, return empty object to load defaults
                resolve({});
              }
            });
          }
        });
      });
    }

    /**
     * Checks if the config file exists and we have reading permissions
     *
     * @returns {Promise} Promise returning true if the file was found and false otherwise.
     * @private
     */

  }, {
    key: '_fileExists',
    value: function _fileExists(filePath) {
      return new Promise(function (resolve) {
        // Check if the config file exists and has reading permissions
        try {
          _fs2.default.access(filePath, _fs2.default.F_OK | _fs2.default.R_OK, function (error) {
            if (error) {
              if (error.errno === -2) {
                logger.info('No ' + _path2.default.basename(filePath) + ' file was found in ' + filePath + '.');
              } else {
                logger.warn(filePath + ' can\'t be read because of reading permission problems. Falling back to default configuration.');
              }
              resolve(false);
            } else {
              logger.info('A config file was found in ' + filePath + '. Using that config.');
              resolve(true);
            }
          });
        } catch (error) {
          logger.error('Error getting access information with fs using `fs.access`. Error:', error);
        }
      });
    }

    /**
     * Reads the config file.
     *
     * @returns {Promise} Promise returning the config if successfully read. Rejects if reading the config failed.
     * @private
     */

  }, {
    key: '_readFile',
    value: function _readFile(file) {
      return new Promise(function (resolve, reject) {
        _fs2.default.readFile(file, 'utf8', function (error, config) {
          if (error) {
            logger.warn('Unable to read config file in (' + file + '). Using default configuration. Error: ', error);
            reject();
          } else {
            resolve(config);
          }
        });
      });
    }

    /**
     * Validate the config using the Joi schema.
     *
     * @param {Object} jsonConfig The config to validate.
     * @private
     */

  }, {
    key: '_validate',
    value: function _validate(jsonConfig) {
      // Validate the JSON config
      try {
        this._jsonConfig = _joi2.default.validate(jsonConfig, _schema2.default).value;
      } catch (error) {
        logger.error('The config in \'config/config.json\' is not a valid config configuration. Error: ', error);
      }
    }
  }]);

  return ServerConfig;
}();

exports.default = ServerConfig;